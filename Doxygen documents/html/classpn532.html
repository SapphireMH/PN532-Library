<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PN532 Library: pn532 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pn532-logo.JPG"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PN532 Library
   &#160;<span id="projectnumber">0.2</span>
   </div>
   <div id="projectbrief">Library to control PN532 breakoutboard (I2C / SPI)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpn532-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pn532 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classpn532.html" title="pn532 class supporting both i2c and spi ">pn532</a> class supporting both i2c and spi  
 <a href="classpn532.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="pn532_8hpp_source.html">pn532.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13848a7bd0e8efddb92bf98baf3a3a9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpn532.html#a13848a7bd0e8efddb92bf98baf3a3a9e">pn532</a> (hwlib::pin_oc &amp;scl, hwlib::pin_oc &amp;sda, hwlib::target::pin_out rst, hwlib::target::pin_in irq=hwlib::target::pins::d13, const bool irq_present=false, const uint8_t &amp;addr=0x24)</td></tr>
<tr class="memdesc:a13848a7bd0e8efddb92bf98baf3a3a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for this class using I2C.  <a href="#a13848a7bd0e8efddb92bf98baf3a3a9e">More...</a><br /></td></tr>
<tr class="separator:a13848a7bd0e8efddb92bf98baf3a3a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85c820b0c05eb73b3360d22393526f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpn532.html#af85c820b0c05eb73b3360d22393526f3">pn532</a> (hwlib::spi_bus_bit_banged_sclk_mosi_miso &amp;spi_bus, hwlib::pin_out &amp;sel, hwlib::target::pin_out rst, hwlib::target::pin_in irq=hwlib::target::pins::d13, const bool irq_present=false)</td></tr>
<tr class="memdesc:af85c820b0c05eb73b3360d22393526f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for this class using SPI.  <a href="#af85c820b0c05eb73b3360d22393526f3">More...</a><br /></td></tr>
<tr class="separator:af85c820b0c05eb73b3360d22393526f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659e36c7fc0f605ebfc8556be16eeccb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpn532.html#a659e36c7fc0f605ebfc8556be16eeccb">get_firmware_version</a> (std::array&lt; uint8_t, 4 &gt; &amp;firmware)</td></tr>
<tr class="memdesc:a659e36c7fc0f605ebfc8556be16eeccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get the boards firmware version.  <a href="#a659e36c7fc0f605ebfc8556be16eeccb">More...</a><br /></td></tr>
<tr class="separator:a659e36c7fc0f605ebfc8556be16eeccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c43af3d9d62b454add98c3d0669eabf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpn532.html#a0c43af3d9d62b454add98c3d0669eabf">read_gpio</a> (std::array&lt; uint8_t, 3 &gt; &amp;gpio_states)</td></tr>
<tr class="memdesc:a0c43af3d9d62b454add98c3d0669eabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read the boards GPIO pins.  <a href="#a0c43af3d9d62b454add98c3d0669eabf">More...</a><br /></td></tr>
<tr class="separator:a0c43af3d9d62b454add98c3d0669eabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db379c079ec3001eb5d4b6d56a9b640"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpn532.html#a3db379c079ec3001eb5d4b6d56a9b640">write_gpio</a> (uint8_t gpio_p3, uint8_t gpio_p7)</td></tr>
<tr class="memdesc:a3db379c079ec3001eb5d4b6d56a9b640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to write to the boards GPIO pins.  <a href="#a3db379c079ec3001eb5d4b6d56a9b640">More...</a><br /></td></tr>
<tr class="separator:a3db379c079ec3001eb5d4b6d56a9b640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cf33361cd8b1dfc84378cdaa324574"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpn532.html#a96cf33361cd8b1dfc84378cdaa324574">get_card_uid</a> (std::array&lt; uint8_t, 7 &gt; &amp;uid)</td></tr>
<tr class="memdesc:a96cf33361cd8b1dfc84378cdaa324574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to receive an NFC cards UID.  <a href="#a96cf33361cd8b1dfc84378cdaa324574">More...</a><br /></td></tr>
<tr class="separator:a96cf33361cd8b1dfc84378cdaa324574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac690893ef6b0877fb697aad6edef1e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpn532.html#aac690893ef6b0877fb697aad6edef1e9">read_eeprom_block</a> (const uint8_t blocknr)</td></tr>
<tr class="memdesc:aac690893ef6b0877fb697aad6edef1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read an nfc cards eeprom, this is read per block.  <a href="#aac690893ef6b0877fb697aad6edef1e9">More...</a><br /></td></tr>
<tr class="separator:aac690893ef6b0877fb697aad6edef1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56108fb1ccd5885131aa7887737660a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpn532.html#a56108fb1ccd5885131aa7887737660a3">write_eeprom_block</a> (const uint8_t blocknr, const std::array&lt; uint8_t, 16 &gt; &amp;data)</td></tr>
<tr class="memdesc:a56108fb1ccd5885131aa7887737660a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to write to an nfc cards eeprom.  <a href="#a56108fb1ccd5885131aa7887737660a3">More...</a><br /></td></tr>
<tr class="separator:a56108fb1ccd5885131aa7887737660a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbfecf1fdfbe7653a6180f5602e3609"><td class="memItemLeft" align="right" valign="top"><a id="a6fbfecf1fdfbe7653a6180f5602e3609"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>read_eeprom_all</b> ()</td></tr>
<tr class="separator:a6fbfecf1fdfbe7653a6180f5602e3609"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classpn532.html" title="pn532 class supporting both i2c and spi ">pn532</a> class supporting both i2c and spi </p>
<p>This class implements all the neccesary functions for controlling an adafruit <a class="el" href="classpn532.html" title="pn532 class supporting both i2c and spi ">pn532</a> breakout board. (presumably also works on the shield version of this board.)</p>
<p>Other <a class="el" href="classpn532.html" title="pn532 class supporting both i2c and spi ">pn532</a> boards are not tested and/or supported through this library. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a13848a7bd0e8efddb92bf98baf3a3a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13848a7bd0e8efddb92bf98baf3a3a9e">&#9670;&nbsp;</a></span>pn532() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pn532::pn532 </td>
          <td>(</td>
          <td class="paramtype">hwlib::pin_oc &amp;&#160;</td>
          <td class="paramname"><em>scl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwlib::pin_oc &amp;&#160;</td>
          <td class="paramname"><em>sda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwlib::target::pin_out&#160;</td>
          <td class="paramname"><em>rst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwlib::target::pin_in&#160;</td>
          <td class="paramname"><em>irq</em> = <code>hwlib::target::pins::d13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>irq_present</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t &amp;&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0x24</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for this class using I2C. </p>
<p>This constructor requires 3 microcontroller pins: scl, sda &amp; reset. Its recommended but not required to also pass a 4th pin, IRQ to reduce the amount of traffic on the i2c bus. An address can also be passed in case the default is not 0x48, see the examples for reference. The constructor automatically resets the chip and configures it for normal operation mode. </p>

</div>
</div>
<a id="af85c820b0c05eb73b3360d22393526f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85c820b0c05eb73b3360d22393526f3">&#9670;&nbsp;</a></span>pn532() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pn532::pn532 </td>
          <td>(</td>
          <td class="paramtype">hwlib::spi_bus_bit_banged_sclk_mosi_miso &amp;&#160;</td>
          <td class="paramname"><em>spi_bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwlib::pin_out &amp;&#160;</td>
          <td class="paramname"><em>sel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwlib::target::pin_out&#160;</td>
          <td class="paramname"><em>rst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwlib::target::pin_in&#160;</td>
          <td class="paramname"><em>irq</em> = <code>hwlib::target::pins::d13</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>irq_present</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for this class using SPI. </p>
<p>This constructor requires 4 microcontroller pins: sclk, mosi, miso &amp; sel. Its recommended but not required to also pass a 5th pin, IRQ to reduce the amount of traffic on the SPI bus. The constructor automatically resets the chip and configures it for normal operation mode. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a96cf33361cd8b1dfc84378cdaa324574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96cf33361cd8b1dfc84378cdaa324574">&#9670;&nbsp;</a></span>get_card_uid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pn532::get_card_uid </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; uint8_t, 7 &gt; &amp;&#160;</td>
          <td class="paramname"><em>uid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to receive an NFC cards UID. </p>
<p>This function waits for a card to enter the the <a class="el" href="classpn532.html" title="pn532 class supporting both i2c and spi ">pn532</a>'s range and then reads its uid. 4 or 7 byte uid cards are supported, however 4 byte uid's are padded with 3 0x00's at its end. The uid gets printed to cout and can then be used in other functions. for authentication or triggering other actions using the uid, an example of this is available, see the main.cpp in the implementation folder. </p>

</div>
</div>
<a id="a659e36c7fc0f605ebfc8556be16eeccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659e36c7fc0f605ebfc8556be16eeccb">&#9670;&nbsp;</a></span>get_firmware_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pn532::get_firmware_version </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; uint8_t, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>firmware</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to get the boards firmware version. </p>
<p>This function sends out a command byte (0x02) with a request to receive the firmware version of the board. This function reads 4 bytes, these bytes get printed to console and returned as std::array so that they can be used for other functionality.</p>
<p>The first byte is the IC version, probably 0x32. The second byte is the firmware version, probably 0x01. The 3th byte is the firmware revision. the 4th byte "support" tells which card types this chip supports 1 = ISO/IEC 14443 TypeA, 2 = ISO/IEC 14443 TypeB, 3 = SO18092, any higher number then the previous 3 means a combination, for example: 7 means that all 3 are supported. </p>

</div>
</div>
<a id="aac690893ef6b0877fb697aad6edef1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac690893ef6b0877fb697aad6edef1e9">&#9670;&nbsp;</a></span>read_eeprom_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pn532::read_eeprom_block </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>blocknr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to read an nfc cards eeprom, this is read per block. </p>
<p>This function receives which block number of the NFC card you wish to read After reading the data gets printed to console. It's important to leave the NFC card on the reader untill the all clear message to ensure the data is read properly.</p>
<dl class="section warning"><dt>Warning</dt><dd>The highest possible block number for a 1K card is 63 and 255 for a 4K card! </dd></dl>

</div>
</div>
<a id="a0c43af3d9d62b454add98c3d0669eabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c43af3d9d62b454add98c3d0669eabf">&#9670;&nbsp;</a></span>read_gpio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pn532::read_gpio </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; uint8_t, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gpio_states</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to read the boards GPIO pins. </p>
<p>WARNING: All gpio pins remember their last state, resetting the <a class="el" href="classpn532.html" title="pn532 class supporting both i2c and spi ">pn532</a> or the arduino does not change this, therefor this library sets all usable GPIO's to LOW at startup to make sure they are in a known state.</p>
<p>This function returns the states of the 3 gpio ports in the formats shown below. GPIO port 7 can only be used with the i2c protocol since these ports are shared with the spi bus, therefor the second byte will not contain any usable data when using SPI. GPIO port 3 numbers 32 and 34 are reserved and will therefor always read as HIGH. The I0I1 byte will always read as 00000001 for I2c and 00000010 for SPI.</p>
<p>gpio port 3 format: 0, 0, P35, P34, P33, P32, P31, P30</p>
<p>(I2C ONLY!) gpio port 7 format: 0, 0, 0, 0, 0, P72, P71, 0</p>
<p>I0I1 (interface select jumpers.) format: 0, 0, 0, 0, 0, 0, SEL0, SEL1 </p>

</div>
</div>
<a id="a56108fb1ccd5885131aa7887737660a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56108fb1ccd5885131aa7887737660a3">&#9670;&nbsp;</a></span>write_eeprom_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pn532::write_eeprom_block </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>blocknr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; uint8_t, 16 &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to write to an nfc cards eeprom. </p>
<p>This function received which block number you wish to write to and a 16 byte array of the data to write. It's important to leave the NFC card on the reader untill the all clear message to ensure the data is read properly.</p>
<dl class="section warning"><dt>Warning</dt><dd>The highest possible block number for a 1K card is 63 and 255 for a 4K card! </dd></dl>

</div>
</div>
<a id="a3db379c079ec3001eb5d4b6d56a9b640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db379c079ec3001eb5d4b6d56a9b640">&#9670;&nbsp;</a></span>write_gpio()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pn532::write_gpio </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>gpio_p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>gpio_p7</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to write to the boards GPIO pins. </p>
<p>WARNING: All gpio pins are HIGH by default, keep this in mind!</p>
<p>This function allows you to turn the extra gpio of the <a class="el" href="classpn532.html" title="pn532 class supporting both i2c and spi ">pn532</a> to high or low. GPIO port 7 can only be used with the i2c protocol since these ports are shared with the spi bus. GPIO port 3 numbers 32 and 34 are reserved and should be high at all times. The arguments are required to be either in decimal or hexadecimal format.</p>
<p>for gpio_p3 use the following byte format: EN, NU, P35, P34, P33, P32, P31, P30</p>
<p>(I2C ONLY!) For gpio_p7 use the following format: EN, NU, NU, NU, NU, P72, P71, 0</p>
<p>EN is enable, set this bit high to use this port. NU means not used, the value on this bit does not matter. each P number corresponds with a physical port on the board. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="pn532_8hpp_source.html">pn532.hpp</a></li>
<li><a class="el" href="pn532_8cpp.html">pn532.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 4 2019 16:21:26 for PN532 Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
